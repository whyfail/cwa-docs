import{_ as s,c as i,o as a,a2 as t}from"./chunks/framework.C94oF1kp.js";const E=JSON.parse('{"title":"脚手架核心","description":"","frontmatter":{"sidebar_position":2,"keywords":["create-wl-app","开箱即用","脚手架","vite","React","Vue3","前端","前端框架","前端开发","前端开发工具"]},"headers":[],"relativePath":"core/脚手架核心.md","filePath":"core/脚手架核心.md"}'),l={name:"core/脚手架核心.md"},e=t(`<h1 id="脚手架核心" tabindex="-1">脚手架核心 <a class="header-anchor" href="#脚手架核心" aria-label="Permalink to &quot;脚手架核心&quot;">​</a></h1><h2 id="代码规范" tabindex="-1">代码规范 <a class="header-anchor" href="#代码规范" aria-label="Permalink to &quot;代码规范&quot;">​</a></h2><ul><li>该脚手架的初心也是为了统一多人协作开发带来的代码不规范问题，所以特意开发了此脚手架；</li><li>有了更加合理的代码规范，可以为后面的开发和维护带来无穷的好处；</li><li>但这个世界上任何的规矩都无法彻底规范开发者，所以提高自身开发规范性才是最重要的；</li></ul><h3 id="eslint" tabindex="-1">Eslint <a class="header-anchor" href="#eslint" aria-label="Permalink to &quot;Eslint&quot;">​</a></h3><ul><li><strong>Eslint</strong> 除了必要的一些代码格式化外，最重要的就是检查代码语法是否错误，将错误展现在开发时候，可以说是开发必备工具；</li><li>该脚手架中添加了比较多的 <strong>Eslint</strong> 规范，针对 <strong>react</strong> 和 <strong>vue3</strong> 用户都带来了不同的配置；</li><li>除了规范必要的语法之外，还有代码格式规范；</li><li><strong>React Eslint</strong> 规范文件位置：<a href="https://gitee.com/whyfail/vite_react_init/blob/master/.eslintrc.cjs" target="_blank" rel="noreferrer">.eslintrc.cjs</a></li><li><strong>Vue3 Eslint</strong> 规范文件位置：<a href="https://gitee.com/whyfail/vite_vue3_init/blob/master/.eslintrc.cjs" target="_blank" rel="noreferrer">.eslintrc.cjs</a></li></ul><h3 id="prettier" tabindex="-1">Prettier <a class="header-anchor" href="#prettier" aria-label="Permalink to &quot;Prettier&quot;">​</a></h3><ul><li><strong>Prettier</strong> 它的作用主要就是将代码格式化的更加的漂亮，且代码风格统一，更利于代码阅读；</li><li>该脚手架的两个模板都用了同一套规则；</li><li><strong>Prettier</strong> 规范文件位置：<a href="https://gitee.com/whyfail/vite_vue3_init/blob/master/.prettierrc.cjs" target="_blank" rel="noreferrer">.prettierrc.cjs</a></li></ul><h3 id="git" tabindex="-1">Git <a class="header-anchor" href="#git" aria-label="Permalink to &quot;Git&quot;">​</a></h3><ul><li>有了以上两个规范，可以将正常开发者的代码进行有效的规范，但也有一种情况就是，无视代码规范，照旧我行我素，然后提交代码，这种情况也会有；</li><li>所以在该脚手架基础上代码提交之前会校验代码，如果代码中对 <strong>Eslint</strong> 报的错误没有进行修复，则无法进行正常提交；</li></ul><h2 id="项目优化" tabindex="-1">项目优化 <a class="header-anchor" href="#项目优化" aria-label="Permalink to &quot;项目优化&quot;">​</a></h2><ul><li>尽管 <strong>Vite</strong> 已经默认优化了很多开发、打包，但本身还是有很多可优化的空间；</li><li>该脚手架的模板项目正对开发过程以及项目打包进行了进一步的配置，可以更加有效的优化打包；</li></ul><h3 id="代码分割" tabindex="-1">代码分割 <a class="header-anchor" href="#代码分割" aria-label="Permalink to &quot;代码分割&quot;">​</a></h3><ul><li><s>引入代码分割插件：<strong>vite-plugin-chunk-split</strong> ，可以对代码进行有效的分割，减少单文件体积；</s></li><li>手动的分割代码块，将比较大的库进行单独打包；</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  rollupOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      manualChunks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        lodashEs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;lodash-es&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        elementPlus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;element-plus&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span></code></pre></div><h3 id="压缩方式" tabindex="-1">压缩方式 <a class="header-anchor" href="#压缩方式" aria-label="Permalink to &quot;压缩方式&quot;">​</a></h3><ul><li>采用<strong>Esbuild</strong></li><li><s><strong>Vite</strong> 默认为 <strong>Esbuild</strong>，它比 <strong>terser</strong> 快 20-40 倍，压缩率只差 1%-2%；</s></li><li><s>打包后去掉 <strong>console</strong> 和 <strong>debugger</strong>，需要注意的是 console 有可能造成内存泄漏，所以还是有必要禁止的；</s></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">esbuild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  drop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;debugger&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;console&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span></code></pre></div><h3 id="适配方法" tabindex="-1">适配方法 <a class="header-anchor" href="#适配方法" aria-label="Permalink to &quot;适配方法&quot;">​</a></h3><ul><li>该脚手架统一使用 <strong>px to rem</strong>这个方案；</li><li>两个模板都引入了 <strong>postcss-pxtorem</strong> 这个库，自动将普通 css 内的 px 单位转换成 rem；</li><li>移除适配方法在<a href="/log/2023-10-17.html">这里</a></li></ul>`,19),n=[e];function r(h,p,o,k,d,g){return a(),i("div",null,n)}const u=s(l,[["render",r]]);export{E as __pageData,u as default};
